---
title: "30 días con RxJS"
categories:
- Aprendizaje
- Programacion
- JavaScript
- RxJS
---

[Jorge Cano], inspirado por la iniciativa de Web Bos de [30 días con JavaScript],
creó [30 días con RxJS]. Y aquí están mis notas, que he ido tomando a lo largo de
los días, siguiendo el camino de Jorge, un día cada vez.

Bueno, Jorge no llegó a producir los 30 días. Veremos hasta qué día llego yo
consumiéndolo.

<!-- more -->

## Día 1

Como suponía, cosas básicas: qué es un Observable, un Observer, un Subject,...
Cómo suscribirse...

Nada realmente interesante

## Día 2

Operadores:

- `scan`: funciona como `reduce` en los arrays
- `throttleTime`: emite el último elemento del flujo cada cierto tiempo
- `map`: nada que decir, lo utiliza para transformar el dato que emitido en el flujo

## Día 3

Cuadrante sobre valores únicos o múltiples, síncronos o asíncronos.

Los observables se encuadran en valores múltiples asíncronos.

En lugar de síncronos/asíncronos, Jorge habla de sistemas productor/consumidor
pull/push. Pull sería cuando es el consumidor el que decide cuando recibir
los datos. Por ejemplo, una función que es llamada. El llamante decide cuándo
va a recibir el valor producido/devuleto por la función.

Los observables serían sistemas push, es el productor quien decide cuándo
se producen los valores. Estos valores son entregados a los consumidores
sin que éstos sepan el momento, son entregados asíncronamente.

Al menos esta relación síncrono-pull/asíncrono-push es la que he hecho
yo en mi cabeza.

## Día 4: observables como generalizaciones de funciones

En otras ocasiones hemos visto los Observables como:

- Promesas para múltiples valores, array asíncrono, o múltiples valores
de forma asíncrona
- Emisores de eventos, cuando se multicastean a través de `Subject`s. Aunque
no es muy común

Hoy hace un paralelismo entre Observables y funciones:

- Suscribirse a un Observable es como llamar a una función. Cada vez que un
Observer se suscribe, el Observable se *ejecuta*
- Tanto las funciones como los Observables son cálculos *lazy*, no se ejecutan
hasta que no se les llama/suscribe
- Dos llamadas distintas ocasionan dos efectos distintos, habrá tantos efectos
como llamadas/suscripciones haya

> Los Observables son asíncronos

Bueno, eso no tiene por qué ser verdad del todo. Cuando un Observer se suscribe
puede recibir los valores de forma síncrona:

```javascript
var foo = Rx.Observable.create(function (observer) {
  console.log('Hello');
  observer.next(42);
  observer.next(100); // "return" another value
  observer.next(200); // "return" yet another
});

console.log('before');
foo.subscribe(function (x) {
  console.log(x);
});
console.log('after');

/* result:
before
Hello
42
100
200
after
*/
```

Y también asíncrona, si a la hora de crear el Observable así lo queremos:

```javascript
var foo = Rx.Observable.create(function (observer) {
  console.log('Hello');
  observer.next(42);
  observer.next(100); // "return" another value
  setTimeout(() => observer.next(200), 1000);
});
```

`func.call()` significa *dame un valor sincrónicamente*

`observable.subscribe()` significa *dame cualquier cantidad de valores,
de forma síncrona o asíncrona*

## Día 5

Los observables se crean con `Observable.create` o con operadores como
`of`, `interval`, `from`,...

Nos cuenta qué papel juegan los métodos `next`, `error` y `complete` de los
Observers.

El método `Observable.subscribe` devuelve una *suscripción*, la cual tiene
un método llamado `unsubscribe` que sirve para cancelar una suscripción.
Este método para cancelar puede ser personalizado a la hora de crear una
suscripción. El método `unsubscribe` es la función que nosotros retornemos
al crear el Observable con `Observable.create`.

[Jorge Cano]: https://twitter.com/jorgeucano
[30 días con JavaScript]: https://javascript30.com/
[30 días con RxJS]: https://medium.com/@jorgeucano/30-d%C3%ADas-con-rxjs-a5b791ece755
